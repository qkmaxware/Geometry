{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Geometry is a C# library for the creation, and manipulation of 3d geometry. Since Geometry is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Geometry Library.","title":"Welcome"},{"location":"#welcome","text":"Geometry is a C# library for the creation, and manipulation of 3d geometry. Since Geometry is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Geometry Library.","title":"Welcome"},{"location":"installing/","text":"Installation Qkmaxware.Geometry is distributed as a Nuget package via Github's Package Repository . Github Access Token Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages. Adding Package Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Geometry package, make sure to specify Github as the package source dotnet add package Qkmaxware.Geometry --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Installation"},{"location":"installing/#installation","text":"Qkmaxware.Geometry is distributed as a Nuget package via Github's Package Repository .","title":"Installation"},{"location":"installing/#github-access-token","text":"Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages.","title":"Github Access Token"},{"location":"installing/#adding-package","text":"Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Geometry package, make sure to specify Github as the package source dotnet add package Qkmaxware.Geometry --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Adding Package"},{"location":"tutorials/01.Creating/","text":"Creating Geometry Qkmaxware.Geometry takes a simple approach to 3D geometry. Geometry is represented as a collection of triangles in which each triangle is defined by 3 vertices in 3D space. The Qkmaxware.Geometry.Mesh class is the base class for most of the operations for 3D geometry. Triangles Upon Triangles Since 3D geometry is just a collection of triangles, creating a mesh can be done by using the Mesh constructor with any IEnumerable<Triangle> collection. Once created, a mesh is immutable. using System.Collections.Generic; using Qkmaxware.Geometry; public class Program { public static void Main(string[] args) { var tris = new List<Triangle>(); // ... add triangles var mesh = new Mesh(tris); } } Primitive Generators Since creating geometry using lists of triangles can be tedious, several generators are provided to quickly create primitive geometry within the Qkmaxware.Geometry.Primitives namespace. Simply construct an object of the given type to automatically generate the required triangles. Plane Planes are 2d flat surfaces composed of two triangles, upper and lower. The geometry created by the Plane generator is positioned in the XY plane with a normal pointed in the positive up (Z) direction. Constructors /// <param name=\"size\">plane size</param> /// <param name=\"centre\">centre</param> public Plane (double size, Vec3 centre) Cube Cubes are 3d objects composed of 6 sides each side having 2 triangles for a total of 12 triangles. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Cube (double size, Vec3 centre) Cylinder A cylinder is a 3D solid with circular end caps perpendicular to the axis. The Cylinder generator allows for specifying different sized end caps. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"upperRadius\">top cap radius</param> /// <param name=\"lowerRadius\">bottom cap radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double upperRadius, double lowerRadius, double height, Vec3 centre, int resolution = 8) /// <summary> /// Cylinder with uniform radius for top and bottom caps /// </summary> /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double radius, double height, Vec3 centre, int resolution = 8) Tube Tubes are cylindrical objects which are hollowed out along the vertical axis. The inner and outer radius allow for specifying the thickness of the tube's walls. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"outerRadius\">outer radius</param> /// <param name=\"innerRadius\">inner radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Tube (double outerRadius, double innerRadius, double height, Vec3 centre, int resolution = 8) Caps A capsule or \"stadium of revolution\" is a 3D geometric shape which is composed of a cylindrical body with two hemispheres for the top and bottom caps. Constructors /// <param name=\"radius\">capsule hemisphere radius</param> /// <param name=\"height\">capsule total height</param> /// <param name=\"centre\">centre of the capsule</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Capsule(double radius, double height, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Cone A cone is a 3D shape that tapers from a smooth flat shape to an apex point. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre of the cone</param> /// <param name=\"resolution\">subdivision level</param> public Cone (double radius, double height, Vec3 centre, int resolution = 8) Sphere The Sphere generator can create spheres of different radius, given that geometry is represented by flat triangles, a sphere cannot be accurately represented. Instead, spheres are approximated using subdivision resolutions. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Sphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Hemisphere Hemispheres are generated as the top half of a sphere plus a flat bottom face. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Hemisphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Torus A torus is a surface of revolution generated by revolving a circle in 3D space. This shape is similar to inner tubes. Similar to the issues with spheres, a torus cannot be completely represented with triangular geometry and instead is approximated using the resolution and segments parametres. Constructors /// <param name=\"majorRadius\">radius of the torus</param> /// <param name=\"minorRadius\">radius of the ring</param> /// <param name=\"centre\">centre of the torus</param> /// <param name=\"resolution\">quality of the rings</param> /// <param name=\"segments\">number of subdivisions on the ring</param> public Torus (double majorRadius, double minorRadius, Vec3 centre, int resolution = 8, int segments = 8) Frustum The Frustum generator creates right-frustum shapes which are parallel truncation cuts of a polygonal pyramid shape. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Frustum (double radius, double height, double ratio, Vec3 centre, int resolution = 4) Nosecone Aerodynamic nosecones represent a wide variety of shapes and the Nosecone generator can create several of the common nosecone shapes. Constructors /// <param name=\"radius\">radius of the cone</param> /// <param name=\"height\">height of the cone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>conic nosecone</returns> public static Nosecone Conic (double radius, double height, int resolution = 8); /// <param name=\"coneRadius\">radius of the upper cone</param> /// <param name=\"coneLength\">length of the upper cone</param> /// <param name=\"frustumRadius\">radius of the lower conic frustum</param> /// <param name=\"frustumLength\">length of the lower conic frustum</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>biconic nosecone</returns> public static Nosecone BiConic(double coneRadius, double coneLength, double frustumRadius, double frustumLength, int resolution = 8); /// <param name=\"radius\">nosecone radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Tangent Ogive Nosecone</returns> public static Nosecone TangentOgive(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"ogiveRadius\">radius of the circle used to define the secant ogive</param> /// <param name=\"conicRadius\">base radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Secant Ogive Nosecone</returns> public static Nosecone SecantOgive(double ogiveRadius, double conicRadius, double height, int resolution = 8, int segments = 8); /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Elliptical Nosecone</returns> public static Nosecone Elliptical(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">parabolic parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Parabolic Nosecone</returns> public static Nosecone Parabolic(double K, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">power series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Power Series Nosecone</returns> public static Nosecone Powerseries (double n, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">Haack series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Haack Series Nosecone</returns> public static Nosecone Haack (double C, double radius, double height, int resolution = 8, int segments = 8); TextMesh TextMesh creates meshes from string data by converting each letter to a 3G geometry. Custom fonts are used to map each character to their appropriate geometry. Constructors /// <param name=\"text\">text</param> public TextMesh (string text); /// <param name=\"font\">font</param> /// <param name=\"text\">text</param> public TextMesh(Font3 font, string text)","title":"Creating Geometry"},{"location":"tutorials/01.Creating/#creating-geometry","text":"Qkmaxware.Geometry takes a simple approach to 3D geometry. Geometry is represented as a collection of triangles in which each triangle is defined by 3 vertices in 3D space. The Qkmaxware.Geometry.Mesh class is the base class for most of the operations for 3D geometry.","title":"Creating Geometry"},{"location":"tutorials/01.Creating/#triangles-upon-triangles","text":"Since 3D geometry is just a collection of triangles, creating a mesh can be done by using the Mesh constructor with any IEnumerable<Triangle> collection. Once created, a mesh is immutable. using System.Collections.Generic; using Qkmaxware.Geometry; public class Program { public static void Main(string[] args) { var tris = new List<Triangle>(); // ... add triangles var mesh = new Mesh(tris); } }","title":"Triangles Upon Triangles"},{"location":"tutorials/01.Creating/#primitive-generators","text":"Since creating geometry using lists of triangles can be tedious, several generators are provided to quickly create primitive geometry within the Qkmaxware.Geometry.Primitives namespace. Simply construct an object of the given type to automatically generate the required triangles.","title":"Primitive Generators"},{"location":"tutorials/01.Creating/#plane","text":"Planes are 2d flat surfaces composed of two triangles, upper and lower. The geometry created by the Plane generator is positioned in the XY plane with a normal pointed in the positive up (Z) direction. Constructors /// <param name=\"size\">plane size</param> /// <param name=\"centre\">centre</param> public Plane (double size, Vec3 centre)","title":"Plane"},{"location":"tutorials/01.Creating/#cube","text":"Cubes are 3d objects composed of 6 sides each side having 2 triangles for a total of 12 triangles. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Cube (double size, Vec3 centre)","title":"Cube"},{"location":"tutorials/01.Creating/#cylinder","text":"A cylinder is a 3D solid with circular end caps perpendicular to the axis. The Cylinder generator allows for specifying different sized end caps. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"upperRadius\">top cap radius</param> /// <param name=\"lowerRadius\">bottom cap radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double upperRadius, double lowerRadius, double height, Vec3 centre, int resolution = 8) /// <summary> /// Cylinder with uniform radius for top and bottom caps /// </summary> /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double radius, double height, Vec3 centre, int resolution = 8)","title":"Cylinder"},{"location":"tutorials/01.Creating/#tube","text":"Tubes are cylindrical objects which are hollowed out along the vertical axis. The inner and outer radius allow for specifying the thickness of the tube's walls. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"outerRadius\">outer radius</param> /// <param name=\"innerRadius\">inner radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Tube (double outerRadius, double innerRadius, double height, Vec3 centre, int resolution = 8)","title":"Tube"},{"location":"tutorials/01.Creating/#caps","text":"A capsule or \"stadium of revolution\" is a 3D geometric shape which is composed of a cylindrical body with two hemispheres for the top and bottom caps. Constructors /// <param name=\"radius\">capsule hemisphere radius</param> /// <param name=\"height\">capsule total height</param> /// <param name=\"centre\">centre of the capsule</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Capsule(double radius, double height, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Caps"},{"location":"tutorials/01.Creating/#cone","text":"A cone is a 3D shape that tapers from a smooth flat shape to an apex point. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre of the cone</param> /// <param name=\"resolution\">subdivision level</param> public Cone (double radius, double height, Vec3 centre, int resolution = 8)","title":"Cone"},{"location":"tutorials/01.Creating/#sphere","text":"The Sphere generator can create spheres of different radius, given that geometry is represented by flat triangles, a sphere cannot be accurately represented. Instead, spheres are approximated using subdivision resolutions. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Sphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Sphere"},{"location":"tutorials/01.Creating/#hemisphere","text":"Hemispheres are generated as the top half of a sphere plus a flat bottom face. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Hemisphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Hemisphere"},{"location":"tutorials/01.Creating/#torus","text":"A torus is a surface of revolution generated by revolving a circle in 3D space. This shape is similar to inner tubes. Similar to the issues with spheres, a torus cannot be completely represented with triangular geometry and instead is approximated using the resolution and segments parametres. Constructors /// <param name=\"majorRadius\">radius of the torus</param> /// <param name=\"minorRadius\">radius of the ring</param> /// <param name=\"centre\">centre of the torus</param> /// <param name=\"resolution\">quality of the rings</param> /// <param name=\"segments\">number of subdivisions on the ring</param> public Torus (double majorRadius, double minorRadius, Vec3 centre, int resolution = 8, int segments = 8)","title":"Torus"},{"location":"tutorials/01.Creating/#frustum","text":"The Frustum generator creates right-frustum shapes which are parallel truncation cuts of a polygonal pyramid shape. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Frustum (double radius, double height, double ratio, Vec3 centre, int resolution = 4)","title":"Frustum"},{"location":"tutorials/01.Creating/#nosecone","text":"Aerodynamic nosecones represent a wide variety of shapes and the Nosecone generator can create several of the common nosecone shapes. Constructors /// <param name=\"radius\">radius of the cone</param> /// <param name=\"height\">height of the cone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>conic nosecone</returns> public static Nosecone Conic (double radius, double height, int resolution = 8); /// <param name=\"coneRadius\">radius of the upper cone</param> /// <param name=\"coneLength\">length of the upper cone</param> /// <param name=\"frustumRadius\">radius of the lower conic frustum</param> /// <param name=\"frustumLength\">length of the lower conic frustum</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>biconic nosecone</returns> public static Nosecone BiConic(double coneRadius, double coneLength, double frustumRadius, double frustumLength, int resolution = 8); /// <param name=\"radius\">nosecone radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Tangent Ogive Nosecone</returns> public static Nosecone TangentOgive(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"ogiveRadius\">radius of the circle used to define the secant ogive</param> /// <param name=\"conicRadius\">base radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Secant Ogive Nosecone</returns> public static Nosecone SecantOgive(double ogiveRadius, double conicRadius, double height, int resolution = 8, int segments = 8); /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Elliptical Nosecone</returns> public static Nosecone Elliptical(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">parabolic parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Parabolic Nosecone</returns> public static Nosecone Parabolic(double K, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">power series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Power Series Nosecone</returns> public static Nosecone Powerseries (double n, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">Haack series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Haack Series Nosecone</returns> public static Nosecone Haack (double C, double radius, double height, int resolution = 8, int segments = 8);","title":"Nosecone"},{"location":"tutorials/01.Creating/#textmesh","text":"TextMesh creates meshes from string data by converting each letter to a 3G geometry. Custom fonts are used to map each character to their appropriate geometry. Constructors /// <param name=\"text\">text</param> public TextMesh (string text); /// <param name=\"font\">font</param> /// <param name=\"text\">text</param> public TextMesh(Font3 font, string text)","title":"TextMesh"},{"location":"tutorials/02.Loading/","text":"Loading 3d Models STL Files Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class. ASCII STL To load an ASCII encoded STL, use the Deserialize method of an StlSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var reader = new StreamReader(\"myfile.stl\")) { var mesh = serializer.Deserialize(reader); } } } Binary STL To load a binary encoded STL, use the Deserialize method of an StlSerializer object with a BinaryReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var stream = new FileStream(\"myfile.stl\", FileMode.Open)) using (var reader = new BinaryReader(stream)) { var mesh = serializer.Deserialize(reader); } } } Generic STL Since STL files can be either ASCII or Binary encoded, loading of an STL file depends on selecting the correct encoding. To aid in loading a generic STL file in which it is not known if the file is ASCII or Binary, the StlSerializer object has a utility method IsStlAscii which can be used to help determine if a given file is in the ASCII format or not. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); var file = \"myfile.stl\" Mesh mesh = null; if (serializer.IsStlAscii(file)) { using (var reader = new StreamReader(file)) { mesh = serializer.Deserialize(reader); } } else { using (var stream = new FileStream(file, FileMode.Open) using (var reader = new BinaryReader(stream)) { mesh = serializer.Deserialize(reader); } } } } Wavefront Obj Files Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class. ASCII Obj To load an ASCII encoded OBJ, use the Deserialize method of an ObjSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new ObjSerializer(); using (var reader = new StreamReader(\"myfile.obj\")) { var mesh = serializer.Deserialize(reader); } } }","title":"Loading 3d Models"},{"location":"tutorials/02.Loading/#loading-3d-models","text":"","title":"Loading 3d Models"},{"location":"tutorials/02.Loading/#stl-files","text":"Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class.","title":"STL Files"},{"location":"tutorials/02.Loading/#ascii-stl","text":"To load an ASCII encoded STL, use the Deserialize method of an StlSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var reader = new StreamReader(\"myfile.stl\")) { var mesh = serializer.Deserialize(reader); } } }","title":"ASCII STL"},{"location":"tutorials/02.Loading/#binary-stl","text":"To load a binary encoded STL, use the Deserialize method of an StlSerializer object with a BinaryReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var stream = new FileStream(\"myfile.stl\", FileMode.Open)) using (var reader = new BinaryReader(stream)) { var mesh = serializer.Deserialize(reader); } } }","title":"Binary STL"},{"location":"tutorials/02.Loading/#generic-stl","text":"Since STL files can be either ASCII or Binary encoded, loading of an STL file depends on selecting the correct encoding. To aid in loading a generic STL file in which it is not known if the file is ASCII or Binary, the StlSerializer object has a utility method IsStlAscii which can be used to help determine if a given file is in the ASCII format or not. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); var file = \"myfile.stl\" Mesh mesh = null; if (serializer.IsStlAscii(file)) { using (var reader = new StreamReader(file)) { mesh = serializer.Deserialize(reader); } } else { using (var stream = new FileStream(file, FileMode.Open) using (var reader = new BinaryReader(stream)) { mesh = serializer.Deserialize(reader); } } } }","title":"Generic STL"},{"location":"tutorials/02.Loading/#wavefront-obj-files","text":"Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class.","title":"Wavefront Obj Files"},{"location":"tutorials/02.Loading/#ascii-obj","text":"To load an ASCII encoded OBJ, use the Deserialize method of an ObjSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new ObjSerializer(); using (var reader = new StreamReader(\"myfile.obj\")) { var mesh = serializer.Deserialize(reader); } } }","title":"ASCII Obj"},{"location":"tutorials/03.Altering/","text":"Altering Geometry The built in Qkmaxware.Geometry.Mesh class used to represent geometry throughout this library is immutable by nature. This means that alterations create new Mesh instances rather than effecting the original mesh data. Affine Transformations In Qkmaxware.Geometry , affine transformations are represented using the Qkmaxware.Geometry.Transformation class. Transformations can then be applied to geometry by pre-multiplying the transformation to the mesh object. Transformations can be combined in sequence by pre-multiplying them. Displacement The displacement transformation is used to move geometry around 3d space. To create a displacement transformation, the Offset static constructor method of the Transformation class can be used to specify the displacement that you want to apply to a mesh. var NewMesh = Transformation.Offset(new Vec3(3, 4, 5)) * OldMesh; Scale The scale transformation will shrink or grow geometry and can be created by the Scale static constructor method of the Transformation class. var NewMesh = Transformation.Scale(2 * Vec3.One) * OldMesh; Rotation Rotation transformations will rotate a geometric object around 3D space. These transformations can be created by the Rx , Ry , Rz , and EulerRotation static constructor method of the Transformation class. // Rotation around a specific axis var NewMesh1 = Transformation.Rx(1.57) * OldMesh; // Rotate 90 degrees around the X axis var NewMesh2 = Transformation.Ry(1.57) * OldMesh; // Rotate 90 degrees around the Y axis var NewMesh3 = Transformation.Rz(1.57) * OldMesh; // Rotate 90 degrees around the Z axis // Arbitrary rotation in 3D space var NewMesh4 = Transformation.EulerRotation(new Vec3(1.57, 0.15, 3.2)) Custom Transformations Besides each of the transformations above, you can define an arbitrary transformation using the Transformation class constructor. For this constructor the elements of the affine transformation matrix are directly provided. Below you can see how the matrix elements map to the constructor parametres. e01 e02 e03 e04 e11 e12 e13 e14 e21 e22 e23 e24 0 0 0 1 var transformation = new Transformation( e01, e02, e03, e04, e11, e12, e13, e14, e21, e22, e23, e24 ) Boolean Operations Boolean operations on polygons are a set of operations that are common in the field of computer aided design. Union Union operations combine polygons from two operations into a new geometry. This can be done with the Union method of the Mesh class, or by using the overloaded + operation. Difference Difference operations are used to cut geometry out of a mesh where it overlaps with another geometry. This is done using the Difference method of the Mesh class, or by using the overloaded - operation. Intersection Intersection operations are used to save only the parts of a geometry where they overlaps with another geometry. This is done using the Intersection method of the Mesh class, or by using the overloaded & operation. Modifier Stacks Geometry modifiers are non-destructive decorators which can be used to apply arbitrary modifications to geometry. Modifiers can be stacked to apply geometric modifications successively without damaging the original geometry, Array The array modifier, Qkmaxware.Geometry.Modifiers.Array , will repeat geometry multiple times moving them by a given amount on each repetition. Path Deformation The path deformation modifier, Qkmaxware.Geometry.Modifiers.PathDeform , will deform a geometry such that it follows a path. Mirror The mirror modifier creates a new mesh that is mirrored across the given axis containing both the original triangles as well as the mirrored triangles. Raw Triangles If the above alteration methods do not work for your use case, you can create new geometry by looping over the individual triangles within a mesh and creating new triangles by altering the vertices. Mesh CustomTransformation(Mesh mesh) { List<Triangle> newTriangles = new List<Triangle>(); foreach (var triangle in mesh) { var vertex1 = AlterVertex(triangle.Item1); var vertex2 = AlterVertex(triangle.Item2); var vertex2 = AlterVertex(triangle.Item3); newTriangles.Add(new Triangle(vertex1, vertex2, vertex3)); } return new Mesh(newTriangles); }","title":"Altering Geometry"},{"location":"tutorials/03.Altering/#altering-geometry","text":"The built in Qkmaxware.Geometry.Mesh class used to represent geometry throughout this library is immutable by nature. This means that alterations create new Mesh instances rather than effecting the original mesh data.","title":"Altering Geometry"},{"location":"tutorials/03.Altering/#affine-transformations","text":"In Qkmaxware.Geometry , affine transformations are represented using the Qkmaxware.Geometry.Transformation class. Transformations can then be applied to geometry by pre-multiplying the transformation to the mesh object. Transformations can be combined in sequence by pre-multiplying them.","title":"Affine Transformations"},{"location":"tutorials/03.Altering/#displacement","text":"The displacement transformation is used to move geometry around 3d space. To create a displacement transformation, the Offset static constructor method of the Transformation class can be used to specify the displacement that you want to apply to a mesh. var NewMesh = Transformation.Offset(new Vec3(3, 4, 5)) * OldMesh;","title":"Displacement"},{"location":"tutorials/03.Altering/#scale","text":"The scale transformation will shrink or grow geometry and can be created by the Scale static constructor method of the Transformation class. var NewMesh = Transformation.Scale(2 * Vec3.One) * OldMesh;","title":"Scale"},{"location":"tutorials/03.Altering/#rotation","text":"Rotation transformations will rotate a geometric object around 3D space. These transformations can be created by the Rx , Ry , Rz , and EulerRotation static constructor method of the Transformation class. // Rotation around a specific axis var NewMesh1 = Transformation.Rx(1.57) * OldMesh; // Rotate 90 degrees around the X axis var NewMesh2 = Transformation.Ry(1.57) * OldMesh; // Rotate 90 degrees around the Y axis var NewMesh3 = Transformation.Rz(1.57) * OldMesh; // Rotate 90 degrees around the Z axis // Arbitrary rotation in 3D space var NewMesh4 = Transformation.EulerRotation(new Vec3(1.57, 0.15, 3.2))","title":"Rotation"},{"location":"tutorials/03.Altering/#custom-transformations","text":"Besides each of the transformations above, you can define an arbitrary transformation using the Transformation class constructor. For this constructor the elements of the affine transformation matrix are directly provided. Below you can see how the matrix elements map to the constructor parametres. e01 e02 e03 e04 e11 e12 e13 e14 e21 e22 e23 e24 0 0 0 1 var transformation = new Transformation( e01, e02, e03, e04, e11, e12, e13, e14, e21, e22, e23, e24 )","title":"Custom Transformations"},{"location":"tutorials/03.Altering/#boolean-operations","text":"Boolean operations on polygons are a set of operations that are common in the field of computer aided design.","title":"Boolean Operations"},{"location":"tutorials/03.Altering/#union","text":"Union operations combine polygons from two operations into a new geometry. This can be done with the Union method of the Mesh class, or by using the overloaded + operation.","title":"Union"},{"location":"tutorials/03.Altering/#difference","text":"Difference operations are used to cut geometry out of a mesh where it overlaps with another geometry. This is done using the Difference method of the Mesh class, or by using the overloaded - operation.","title":"Difference"},{"location":"tutorials/03.Altering/#intersection","text":"Intersection operations are used to save only the parts of a geometry where they overlaps with another geometry. This is done using the Intersection method of the Mesh class, or by using the overloaded & operation.","title":"Intersection"},{"location":"tutorials/03.Altering/#modifier-stacks","text":"Geometry modifiers are non-destructive decorators which can be used to apply arbitrary modifications to geometry. Modifiers can be stacked to apply geometric modifications successively without damaging the original geometry,","title":"Modifier Stacks"},{"location":"tutorials/03.Altering/#array","text":"The array modifier, Qkmaxware.Geometry.Modifiers.Array , will repeat geometry multiple times moving them by a given amount on each repetition.","title":"Array"},{"location":"tutorials/03.Altering/#path-deformation","text":"The path deformation modifier, Qkmaxware.Geometry.Modifiers.PathDeform , will deform a geometry such that it follows a path.","title":"Path Deformation"},{"location":"tutorials/03.Altering/#mirror","text":"The mirror modifier creates a new mesh that is mirrored across the given axis containing both the original triangles as well as the mirrored triangles.","title":"Mirror"},{"location":"tutorials/03.Altering/#raw-triangles","text":"If the above alteration methods do not work for your use case, you can create new geometry by looping over the individual triangles within a mesh and creating new triangles by altering the vertices. Mesh CustomTransformation(Mesh mesh) { List<Triangle> newTriangles = new List<Triangle>(); foreach (var triangle in mesh) { var vertex1 = AlterVertex(triangle.Item1); var vertex2 = AlterVertex(triangle.Item2); var vertex2 = AlterVertex(triangle.Item3); newTriangles.Add(new Triangle(vertex1, vertex2, vertex3)); } return new Mesh(newTriangles); }","title":"Raw Triangles"},{"location":"tutorials/04.Exporting/","text":"Exporting 3d Models STL Files Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class. ASCII STL To save an ASCII encoded STL, use the Serialize method of an StlSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new StreamWriter(\"myfile.stl\")) { writer.Write(serializer.Serialize(mesh)); } } } Binary STL To save an binary encoded STL, use the SerializeBinary method of an StlSerializer object to write mesh data to a given BinaryWriter . using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new BinaryWriter(File.Open(\"myfile.stl\", FileMode.Create))) { exporter.SerializeBinary(mesh, writer); } } } Wavefront Obj Files Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class. ASCII Obj To save an ASCII encoded OBJ, use the Serialize method of an ObjSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new ObjSerializer(); using (var writer = new StreamWriter(\"myfile.obj\")) { writer.Write(serializer.Serialize(mesh)); } } } Extensible 3D Graphics X3d Files Extensible 3D Graphics files or X3D files is a royalty free xml based format for representing 3D computer graphics. Given that X3D files are an based on the XML format, there only is an ASCII version available for this format. Saving of X3D files is supported via the Qkmaxware.Geometry.IO.X3dSerializer class. ASCII X3d To save an ASCII encoded X3D, use the Serialize method of an X3dSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new X3dSerializer(); using (var writer = new StreamWriter(\"myfile.x3d\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"Exporting 3d Models"},{"location":"tutorials/04.Exporting/#exporting-3d-models","text":"","title":"Exporting 3d Models"},{"location":"tutorials/04.Exporting/#stl-files","text":"Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class.","title":"STL Files"},{"location":"tutorials/04.Exporting/#ascii-stl","text":"To save an ASCII encoded STL, use the Serialize method of an StlSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new StreamWriter(\"myfile.stl\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII STL"},{"location":"tutorials/04.Exporting/#binary-stl","text":"To save an binary encoded STL, use the SerializeBinary method of an StlSerializer object to write mesh data to a given BinaryWriter . using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new BinaryWriter(File.Open(\"myfile.stl\", FileMode.Create))) { exporter.SerializeBinary(mesh, writer); } } }","title":"Binary STL"},{"location":"tutorials/04.Exporting/#wavefront-obj-files","text":"Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class.","title":"Wavefront Obj Files"},{"location":"tutorials/04.Exporting/#ascii-obj","text":"To save an ASCII encoded OBJ, use the Serialize method of an ObjSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new ObjSerializer(); using (var writer = new StreamWriter(\"myfile.obj\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII Obj"},{"location":"tutorials/04.Exporting/#extensible-3d-graphics-x3d-files","text":"Extensible 3D Graphics files or X3D files is a royalty free xml based format for representing 3D computer graphics. Given that X3D files are an based on the XML format, there only is an ASCII version available for this format. Saving of X3D files is supported via the Qkmaxware.Geometry.IO.X3dSerializer class.","title":"Extensible 3D Graphics X3d Files"},{"location":"tutorials/04.Exporting/#ascii-x3d","text":"To save an ASCII encoded X3D, use the Serialize method of an X3dSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new X3dSerializer(); using (var writer = new StreamWriter(\"myfile.x3d\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII X3d"}]}