{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Geometry is a C# library for the creation, and manipulation of 3d geometry. Since Geometry is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Geometry Library.","title":"Welcome"},{"location":"#welcome","text":"Geometry is a C# library for the creation, and manipulation of 3d geometry. Since Geometry is built off of .Net Standard 2.1 , it is compatible with the .Net Framework as well as .Net Core . This site serves as a resource for installing and using the Geometry Library.","title":"Welcome"},{"location":"installing/","text":"Installation Qkmaxware.Geometry is distributed as a Nuget package via Github's Package Repository . Github Access Token Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages. Adding Package Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Geometry package, make sure to specify Github as the package source dotnet add package Qkmaxware.Geometry --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Installation"},{"location":"installing/#installation","text":"Qkmaxware.Geometry is distributed as a Nuget package via Github's Package Repository .","title":"Installation"},{"location":"installing/#github-access-token","text":"Github requires that all users will need to authenticate with Github in order to download packages. At the time of writing, the process for creating such a token located on docs.github.com . When creating this token make sure that it permissions to read:packages enabled which is required to download github packages.","title":"Github Access Token"},{"location":"installing/#adding-package","text":"Create an empty project or use an existing .Net project dotnet new console Create a new file at the root of the project named nuget.config and paste the following xml into it. Replace %USERNAME% with your Github username and %ACCESS_TOKEN% with the access token that you created previously. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"qkmaxware\" value=\"https://nuget.pkg.github.com/qkmaxware/index.json\" /> </packageSources> <packageSourceCredentials> <qkmaxware> <add key=\"Username\" value=\"%USERNAME%\" /> <add key=\"ClearTextPassword\" value=\"%ACCESS_TOKEN%\" /> </qkmaxware> </packageSourceCredentials> </configuration> Add the Qkmaxware.Geometry package, make sure to specify Github as the package source dotnet add package Qkmaxware.Geometry --source \"https://nuget.pkg.github.com/qkmaxware/index.json\"","title":"Adding Package"},{"location":"tutorials/mesh/01.Creating/","text":"Creating Mesh Qkmaxware.Geometry takes a simple approach to 3D mesh data. Mesh geometry is represented as a collection of triangles in which each triangle is defined by 3 vertices in 3D space. The Qkmaxware.Geometry.ListMesh class is the base class for most of the operations for 3D geometry. Triangles Upon Triangles Since mesh based geometry is just a collection of triangles, creating a mesh can be done by using the ListMesh constructor with any IEnumerable<Triangle> collection. Once created, a mesh is immutable. Alternatively, create any class that inherits from the IMesh interface. using System.Collections.Generic; using Qkmaxware.Geometry; public class Program { public static void Main(string[] args) { var tris = new List<Triangle>(); // ... add triangles var mesh = new ListMesh(tris); } } Primitive Generators Since creating geometry using lists of triangles can be tedious, several generators are provided to quickly create primitive geometry within the Qkmaxware.Geometry.Primitives namespace. Simply construct an object of the given type to automatically generate the required triangles. Plane Planes are 2d flat surfaces composed of two triangles, upper and lower. The geometry created by the Plane generator is positioned in the XY plane with a normal pointed in the positive up (Z) direction. Constructors /// <param name=\"size\">plane size</param> /// <param name=\"centre\">centre</param> public Plane (double size, Vec3 centre) Cube Cubes are 3d objects composed of 6 sides each side having 2 triangles for a total of 12 triangles. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Cube (double size, Vec3 centre) Cylinder A cylinder is a 3D solid with circular end caps perpendicular to the axis. The Cylinder generator allows for specifying different sized end caps. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"upperRadius\">top cap radius</param> /// <param name=\"lowerRadius\">bottom cap radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double upperRadius, double lowerRadius, double height, Vec3 centre, int resolution = 8) /// <summary> /// Cylinder with uniform radius for top and bottom caps /// </summary> /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double radius, double height, Vec3 centre, int resolution = 8) Tube Tubes are cylindrical objects which are hollowed out along the vertical axis. The inner and outer radius allow for specifying the thickness of the tube's walls. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"outerRadius\">outer radius</param> /// <param name=\"innerRadius\">inner radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Tube (double outerRadius, double innerRadius, double height, Vec3 centre, int resolution = 8) Caps A capsule or \"stadium of revolution\" is a 3D geometric shape which is composed of a cylindrical body with two hemispheres for the top and bottom caps. Constructors /// <param name=\"radius\">capsule hemisphere radius</param> /// <param name=\"height\">capsule total height</param> /// <param name=\"centre\">centre of the capsule</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Capsule(double radius, double height, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Cone A cone is a 3D shape that tapers from a smooth flat shape to an apex point. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre of the cone</param> /// <param name=\"resolution\">subdivision level</param> public Cone (double radius, double height, Vec3 centre, int resolution = 8) Sphere The Sphere generator can create spheres of different radius, given that geometry is represented by flat triangles, a sphere cannot be accurately represented. Instead, spheres are approximated using subdivision resolutions. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Sphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Hemisphere Hemispheres are generated as the top half of a sphere plus a flat bottom face. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Hemisphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8) Torus A torus is a surface of revolution generated by revolving a circle in 3D space. This shape is similar to inner tubes. Similar to the issues with spheres, a torus cannot be completely represented with triangular geometry and instead is approximated using the resolution and segments parametres. Constructors /// <param name=\"majorRadius\">radius of the torus</param> /// <param name=\"minorRadius\">radius of the ring</param> /// <param name=\"centre\">centre of the torus</param> /// <param name=\"resolution\">quality of the rings</param> /// <param name=\"segments\">number of subdivisions on the ring</param> public Torus (double majorRadius, double minorRadius, Vec3 centre, int resolution = 8, int segments = 8) Frustum The Frustum generator creates right-frustum shapes which are parallel truncation cuts of a polygonal pyramid shape. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Frustum (double radius, double height, double ratio, Vec3 centre, int resolution = 4) Nosecone Aerodynamic nosecones represent a wide variety of shapes and the Nosecone generator can create several of the common nosecone shapes. Constructors /// <param name=\"radius\">radius of the cone</param> /// <param name=\"height\">height of the cone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>conic nosecone</returns> public ConicNosecone (double radius, double height, int resolution = 8); /// <param name=\"coneRadius\">radius of the upper cone</param> /// <param name=\"coneLength\">length of the upper cone</param> /// <param name=\"frustumRadius\">radius of the lower conic frustum</param> /// <param name=\"frustumLength\">length of the lower conic frustum</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>biconic nosecone</returns> public BiConicNosecone(double coneRadius, double coneLength, double frustumRadius, double frustumLength, int resolution = 8); /// <param name=\"radius\">nosecone radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Tangent Ogive Nosecone</returns> public TangentOgiveNosecone(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"ogiveRadius\">radius of the circle used to define the secant ogive</param> /// <param name=\"conicRadius\">base radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Secant Ogive Nosecone</returns> public SecantOgiveNosecone(double ogiveRadius, double conicRadius, double height, int resolution = 8, int segments = 8); /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Elliptical Nosecone</returns> public EllipticalNosecone(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">parabolic parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Parabolic Nosecone</returns> public ParabolicNosecone(double K, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">power series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Power Series Nosecone</returns> public PowerseriesNosecone (double n, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">Haack series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Haack Series Nosecone</returns> public HaackNosecone (double C, double radius, double height, int resolution = 8, int segments = 8); Arrow Arrows are pointers looking in the +Z direction. Constructors /// <param name=\"length\">length of the arrow</param> /// <param name=\"radius\">radius of the arrow head</param> /// <param name=\"resolution\">subdivision level</param> public Arrow(double length = 1, double radius = 0.08, int resolution = 8) TextMesh TextMesh creates meshes from string data by converting each letter to a 3G geometry. Custom fonts are used to map each character to their appropriate geometry. Constructors /// <param name=\"text\">text</param> public TextMesh (string text); /// <param name=\"font\">font</param> /// <param name=\"text\">text</param> public TextMesh(Font3 font, string text)","title":"Creating Mesh"},{"location":"tutorials/mesh/01.Creating/#creating-mesh","text":"Qkmaxware.Geometry takes a simple approach to 3D mesh data. Mesh geometry is represented as a collection of triangles in which each triangle is defined by 3 vertices in 3D space. The Qkmaxware.Geometry.ListMesh class is the base class for most of the operations for 3D geometry.","title":"Creating Mesh"},{"location":"tutorials/mesh/01.Creating/#triangles-upon-triangles","text":"Since mesh based geometry is just a collection of triangles, creating a mesh can be done by using the ListMesh constructor with any IEnumerable<Triangle> collection. Once created, a mesh is immutable. Alternatively, create any class that inherits from the IMesh interface. using System.Collections.Generic; using Qkmaxware.Geometry; public class Program { public static void Main(string[] args) { var tris = new List<Triangle>(); // ... add triangles var mesh = new ListMesh(tris); } }","title":"Triangles Upon Triangles"},{"location":"tutorials/mesh/01.Creating/#primitive-generators","text":"Since creating geometry using lists of triangles can be tedious, several generators are provided to quickly create primitive geometry within the Qkmaxware.Geometry.Primitives namespace. Simply construct an object of the given type to automatically generate the required triangles.","title":"Primitive Generators"},{"location":"tutorials/mesh/01.Creating/#plane","text":"Planes are 2d flat surfaces composed of two triangles, upper and lower. The geometry created by the Plane generator is positioned in the XY plane with a normal pointed in the positive up (Z) direction. Constructors /// <param name=\"size\">plane size</param> /// <param name=\"centre\">centre</param> public Plane (double size, Vec3 centre)","title":"Plane"},{"location":"tutorials/mesh/01.Creating/#cube","text":"Cubes are 3d objects composed of 6 sides each side having 2 triangles for a total of 12 triangles. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Cube (double size, Vec3 centre)","title":"Cube"},{"location":"tutorials/mesh/01.Creating/#cylinder","text":"A cylinder is a 3D solid with circular end caps perpendicular to the axis. The Cylinder generator allows for specifying different sized end caps. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"upperRadius\">top cap radius</param> /// <param name=\"lowerRadius\">bottom cap radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double upperRadius, double lowerRadius, double height, Vec3 centre, int resolution = 8) /// <summary> /// Cylinder with uniform radius for top and bottom caps /// </summary> /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Cylinder (double radius, double height, Vec3 centre, int resolution = 8)","title":"Cylinder"},{"location":"tutorials/mesh/01.Creating/#tube","text":"Tubes are cylindrical objects which are hollowed out along the vertical axis. The inner and outer radius allow for specifying the thickness of the tube's walls. Constructors /// <summary> /// Cylinder with different radii for top and bottom caps /// </summary> /// <param name=\"outerRadius\">outer radius</param> /// <param name=\"innerRadius\">inner radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre</param> /// <param name=\"resolution\">subdivision level</param> public Tube (double outerRadius, double innerRadius, double height, Vec3 centre, int resolution = 8)","title":"Tube"},{"location":"tutorials/mesh/01.Creating/#caps","text":"A capsule or \"stadium of revolution\" is a 3D geometric shape which is composed of a cylindrical body with two hemispheres for the top and bottom caps. Constructors /// <param name=\"radius\">capsule hemisphere radius</param> /// <param name=\"height\">capsule total height</param> /// <param name=\"centre\">centre of the capsule</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Capsule(double radius, double height, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Caps"},{"location":"tutorials/mesh/01.Creating/#cone","text":"A cone is a 3D shape that tapers from a smooth flat shape to an apex point. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"height\">height</param> /// <param name=\"centre\">centre of the cone</param> /// <param name=\"resolution\">subdivision level</param> public Cone (double radius, double height, Vec3 centre, int resolution = 8)","title":"Cone"},{"location":"tutorials/mesh/01.Creating/#sphere","text":"The Sphere generator can create spheres of different radius, given that geometry is represented by flat triangles, a sphere cannot be accurately represented. Instead, spheres are approximated using subdivision resolutions. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Sphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Sphere"},{"location":"tutorials/mesh/01.Creating/#hemisphere","text":"Hemispheres are generated as the top half of a sphere plus a flat bottom face. Constructors /// <param name=\"radius\">radius</param> /// <param name=\"centre\">centre point</param> /// <param name=\"horizontalResolution\">longitude subdivision levels</param> /// <param name=\"verticalResolution\">latitude subdivision level</param> public Hemisphere(double radius, Vec3 centre, int horizontalResolution = 8, int verticalResolution = 8)","title":"Hemisphere"},{"location":"tutorials/mesh/01.Creating/#torus","text":"A torus is a surface of revolution generated by revolving a circle in 3D space. This shape is similar to inner tubes. Similar to the issues with spheres, a torus cannot be completely represented with triangular geometry and instead is approximated using the resolution and segments parametres. Constructors /// <param name=\"majorRadius\">radius of the torus</param> /// <param name=\"minorRadius\">radius of the ring</param> /// <param name=\"centre\">centre of the torus</param> /// <param name=\"resolution\">quality of the rings</param> /// <param name=\"segments\">number of subdivisions on the ring</param> public Torus (double majorRadius, double minorRadius, Vec3 centre, int resolution = 8, int segments = 8)","title":"Torus"},{"location":"tutorials/mesh/01.Creating/#frustum","text":"The Frustum generator creates right-frustum shapes which are parallel truncation cuts of a polygonal pyramid shape. Constructors /// <param name=\"size\">size of the cube</param> /// <param name=\"centre\">centre of the cube</param> public Frustum (double radius, double height, double ratio, Vec3 centre, int resolution = 4)","title":"Frustum"},{"location":"tutorials/mesh/01.Creating/#nosecone","text":"Aerodynamic nosecones represent a wide variety of shapes and the Nosecone generator can create several of the common nosecone shapes. Constructors /// <param name=\"radius\">radius of the cone</param> /// <param name=\"height\">height of the cone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>conic nosecone</returns> public ConicNosecone (double radius, double height, int resolution = 8); /// <param name=\"coneRadius\">radius of the upper cone</param> /// <param name=\"coneLength\">length of the upper cone</param> /// <param name=\"frustumRadius\">radius of the lower conic frustum</param> /// <param name=\"frustumLength\">length of the lower conic frustum</param> /// <param name=\"resolution\">higher number is more circular</param> /// <returns>biconic nosecone</returns> public BiConicNosecone(double coneRadius, double coneLength, double frustumRadius, double frustumLength, int resolution = 8); /// <param name=\"radius\">nosecone radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Tangent Ogive Nosecone</returns> public TangentOgiveNosecone(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"ogiveRadius\">radius of the circle used to define the secant ogive</param> /// <param name=\"conicRadius\">base radius</param> /// <param name=\"height\">nosecone height</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Secant Ogive Nosecone</returns> public SecantOgiveNosecone(double ogiveRadius, double conicRadius, double height, int resolution = 8, int segments = 8); /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Elliptical Nosecone</returns> public EllipticalNosecone(double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">parabolic parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Parabolic Nosecone</returns> public ParabolicNosecone(double K, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">power series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Power Series Nosecone</returns> public PowerseriesNosecone (double n, double radius, double height, int resolution = 8, int segments = 8); /// <param name=\"K\">Haack series parametre between 0 and 1</param> /// <param name=\"radius\">radius of the nosecone</param> /// <param name=\"height\">height of the nosecone</param> /// <param name=\"resolution\">higher number is more circular</param> /// <param name=\"segments\">higher number is more smooth</param> /// <returns>Haack Series Nosecone</returns> public HaackNosecone (double C, double radius, double height, int resolution = 8, int segments = 8);","title":"Nosecone"},{"location":"tutorials/mesh/01.Creating/#arrow","text":"Arrows are pointers looking in the +Z direction. Constructors /// <param name=\"length\">length of the arrow</param> /// <param name=\"radius\">radius of the arrow head</param> /// <param name=\"resolution\">subdivision level</param> public Arrow(double length = 1, double radius = 0.08, int resolution = 8)","title":"Arrow"},{"location":"tutorials/mesh/01.Creating/#textmesh","text":"TextMesh creates meshes from string data by converting each letter to a 3G geometry. Custom fonts are used to map each character to their appropriate geometry. Constructors /// <param name=\"text\">text</param> public TextMesh (string text); /// <param name=\"font\">font</param> /// <param name=\"text\">text</param> public TextMesh(Font3 font, string text)","title":"TextMesh"},{"location":"tutorials/mesh/02.Loading/","text":"Loading 3d Models STL Files Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class. ASCII STL To load an ASCII encoded STL, use the Deserialize method of an StlSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var reader = new StreamReader(\"myfile.stl\")) { var mesh = serializer.Deserialize(reader); } } } Binary STL To load a binary encoded STL, use the Deserialize method of an StlSerializer object with a BinaryReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var stream = new FileStream(\"myfile.stl\", FileMode.Open)) using (var reader = new BinaryReader(stream)) { var mesh = serializer.Deserialize(reader); } } } Generic STL Since STL files can be either ASCII or Binary encoded, loading of an STL file depends on selecting the correct encoding. To aid in loading a generic STL file in which it is not known if the file is ASCII or Binary, the StlSerializer object has a utility method IsStlAscii which can be used to help determine if a given file is in the ASCII format or not. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); var file = \"myfile.stl\" IMesh mesh = null; if (serializer.IsStlAscii(file)) { using (var reader = new StreamReader(file)) { mesh = serializer.Deserialize(reader); } } else { using (var stream = new FileStream(file, FileMode.Open)) using (var reader = new BinaryReader(stream)) { mesh = serializer.Deserialize(reader); } } } } Alternatively the StlSerializer class also has a DeserializeFromFile method which will do the same job as the above code given the path to an STL file on the hard drive. Wavefront Obj Files Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class. ASCII Obj To load an ASCII encoded OBJ, use the Deserialize method of an ObjSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new ObjSerializer(); using (var reader = new StreamReader(\"myfile.obj\")) { var mesh = serializer.Deserialize(reader); } } }","title":"Loading 3d Models"},{"location":"tutorials/mesh/02.Loading/#loading-3d-models","text":"","title":"Loading 3d Models"},{"location":"tutorials/mesh/02.Loading/#stl-files","text":"Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class.","title":"STL Files"},{"location":"tutorials/mesh/02.Loading/#ascii-stl","text":"To load an ASCII encoded STL, use the Deserialize method of an StlSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var reader = new StreamReader(\"myfile.stl\")) { var mesh = serializer.Deserialize(reader); } } }","title":"ASCII STL"},{"location":"tutorials/mesh/02.Loading/#binary-stl","text":"To load a binary encoded STL, use the Deserialize method of an StlSerializer object with a BinaryReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); using (var stream = new FileStream(\"myfile.stl\", FileMode.Open)) using (var reader = new BinaryReader(stream)) { var mesh = serializer.Deserialize(reader); } } }","title":"Binary STL"},{"location":"tutorials/mesh/02.Loading/#generic-stl","text":"Since STL files can be either ASCII or Binary encoded, loading of an STL file depends on selecting the correct encoding. To aid in loading a generic STL file in which it is not known if the file is ASCII or Binary, the StlSerializer object has a utility method IsStlAscii which can be used to help determine if a given file is in the ASCII format or not. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new StlSerializer(); var file = \"myfile.stl\" IMesh mesh = null; if (serializer.IsStlAscii(file)) { using (var reader = new StreamReader(file)) { mesh = serializer.Deserialize(reader); } } else { using (var stream = new FileStream(file, FileMode.Open)) using (var reader = new BinaryReader(stream)) { mesh = serializer.Deserialize(reader); } } } } Alternatively the StlSerializer class also has a DeserializeFromFile method which will do the same job as the above code given the path to an STL file on the hard drive.","title":"Generic STL"},{"location":"tutorials/mesh/02.Loading/#wavefront-obj-files","text":"Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class.","title":"Wavefront Obj Files"},{"location":"tutorials/mesh/02.Loading/#ascii-obj","text":"To load an ASCII encoded OBJ, use the Deserialize method of an ObjSerializer object with a TextReader as the argument. using System.IO; using Qkmaxware.Geometry.IO; public class Program { public static void Main(string[] args) { var serializer = new ObjSerializer(); using (var reader = new StreamReader(\"myfile.obj\")) { var mesh = serializer.Deserialize(reader); } } }","title":"ASCII Obj"},{"location":"tutorials/mesh/03.Altering/","text":"Altering Geometry The built in Qkmaxware.Geometry.IMesh interface used to represent mesh based geometry throughout this library. ListMesh is a concrete implementation of this interface which uses a list as its storage structure and is immutable by nature. This means that alterations create new ListMesh instances rather than effecting the original mesh data. Affine Transformations In Qkmaxware.Geometry , affine transformations are represented using the Qkmaxware.Geometry.Transformation class. Transformations can then be applied to geometry by pre-multiplying the transformation to the mesh object. Transformations can be combined in sequence by pre-multiplying them. Displacement The displacement transformation is used to move geometry around 3d space. To create a displacement transformation, the Offset static constructor method of the Transformation class can be used to specify the displacement that you want to apply to a mesh. var NewMesh = Transformation.Offset(new Vec3(3, 4, 5)) * OldMesh; Scale The scale transformation will shrink or grow geometry and can be created by the Scale static constructor method of the Transformation class. var NewMesh = Transformation.Scale(2 * Vec3.One) * OldMesh; Rotation Rotation transformations will rotate a geometric object around 3D space. These transformations can be created by the Rx , Ry , Rz , and EulerRotation static constructor method of the Transformation class. // Rotation around a specific axis var NewMesh1 = Transformation.Rx(1.57) * OldMesh; // Rotate 90 degrees around the X axis var NewMesh2 = Transformation.Ry(1.57) * OldMesh; // Rotate 90 degrees around the Y axis var NewMesh3 = Transformation.Rz(1.57) * OldMesh; // Rotate 90 degrees around the Z axis // Arbitrary rotation in 3D space var NewMesh4 = Transformation.EulerRotation(new Vec3(1.57, 0.15, 3.2)) Custom Transformations Besides each of the transformations above, you can define an arbitrary transformation using the Transformation class constructor. For this constructor the elements of the affine transformation matrix are directly provided. Below you can see how the matrix elements map to the constructor parametres. e01 e02 e03 e04 e11 e12 e13 e14 e21 e22 e23 e24 0 0 0 1 var transformation = new Transformation( e01, e02, e03, e04, e11, e12, e13, e14, e21, e22, e23, e24 ) Modifier Stacks Geometry modifiers are non-destructive decorators which can be used to apply arbitrary modifications to geometry. Modifiers can be stacked to apply geometric modifications successively without damaging the original geometry, Array The array modifier, Qkmaxware.Geometry.Modifiers.Array , will repeat geometry multiple times moving them by a given amount on each repetition. Path Deformation The path deformation modifier, Qkmaxware.Geometry.Modifiers.PathDeform , will deform a geometry such that it follows a path. Mirror The mirror modifier creates a new mesh that is mirrored across the given axis containing both the original triangles as well as the mirrored triangles. Subdivide The subdivide modifier creates a new mesh in which each triangle has be sub-divided into 4 smaller triangles. This modifier can be used to increase the resolution of a given geometry. Scale The scale modifier operates identically to the scale transformation. However, by being a modifier it does not allocate any additional mesh data until it is used whereas the transformation immediately creates a new mesh with the modified vertices. Translate the translate modifier operates identically to the offset transformation but as a modifier. This behaves the same as the scale modifier. Path To Mesh The path to mesh modifier creates a tube shaped mesh by following a path segment. Effectively this allows for one to convert a path object into a 3d mesh which follows the shape of the path. Render GCode The render g-code modifier uses tubes to trace the path for a print-head of a 3D printer in order to convert 3D printer flavoured GCode back to a 3d model. Explode The explode modifier pushes the original triangles apart as if they were exploded outwards from their original locations. Boolean Operations Boolean operations are a set of operations common in the field of computer aided design. There are several different modifier which are capable of performing boolean operations. Union the union modifier combines non-overlapping polygons from two geometry into a new geometry. Besides being offered as a modifier, this operation can also be done with the Union method of the ListMesh class, or by using the overloaded + operation. Difference the difference modifier is used to cut geometry out of a mesh where it overlaps with another geometry. Besides being offered as a modifier, this operation can also be done using the Difference method of the ListMesh class, or by using the overloaded - operation. Intersection The intersection modifier is used to save only the parts of a geometry where they overlaps with another geometry. Besides being offered as a modifier, this operation can also be done using the Intersection method of the ListMesh class, or by using the overloaded & operation. Raw Triangles If the above alteration methods do not work for your use case, you can create new geometry by looping over the individual triangles within a mesh and creating new triangles by altering the vertices. IMesh CustomTransformation(IMesh mesh) { List<Triangle> newTriangles = new List<Triangle>(); foreach (var triangle in mesh) { var vertex1 = AlterVertex(triangle.Item1); var vertex2 = AlterVertex(triangle.Item2); var vertex2 = AlterVertex(triangle.Item3); newTriangles.Add(new Triangle(vertex1, vertex2, vertex3)); } return new ListMesh(newTriangles); }","title":"Altering Geometry"},{"location":"tutorials/mesh/03.Altering/#altering-geometry","text":"The built in Qkmaxware.Geometry.IMesh interface used to represent mesh based geometry throughout this library. ListMesh is a concrete implementation of this interface which uses a list as its storage structure and is immutable by nature. This means that alterations create new ListMesh instances rather than effecting the original mesh data.","title":"Altering Geometry"},{"location":"tutorials/mesh/03.Altering/#affine-transformations","text":"In Qkmaxware.Geometry , affine transformations are represented using the Qkmaxware.Geometry.Transformation class. Transformations can then be applied to geometry by pre-multiplying the transformation to the mesh object. Transformations can be combined in sequence by pre-multiplying them.","title":"Affine Transformations"},{"location":"tutorials/mesh/03.Altering/#displacement","text":"The displacement transformation is used to move geometry around 3d space. To create a displacement transformation, the Offset static constructor method of the Transformation class can be used to specify the displacement that you want to apply to a mesh. var NewMesh = Transformation.Offset(new Vec3(3, 4, 5)) * OldMesh;","title":"Displacement"},{"location":"tutorials/mesh/03.Altering/#scale","text":"The scale transformation will shrink or grow geometry and can be created by the Scale static constructor method of the Transformation class. var NewMesh = Transformation.Scale(2 * Vec3.One) * OldMesh;","title":"Scale"},{"location":"tutorials/mesh/03.Altering/#rotation","text":"Rotation transformations will rotate a geometric object around 3D space. These transformations can be created by the Rx , Ry , Rz , and EulerRotation static constructor method of the Transformation class. // Rotation around a specific axis var NewMesh1 = Transformation.Rx(1.57) * OldMesh; // Rotate 90 degrees around the X axis var NewMesh2 = Transformation.Ry(1.57) * OldMesh; // Rotate 90 degrees around the Y axis var NewMesh3 = Transformation.Rz(1.57) * OldMesh; // Rotate 90 degrees around the Z axis // Arbitrary rotation in 3D space var NewMesh4 = Transformation.EulerRotation(new Vec3(1.57, 0.15, 3.2))","title":"Rotation"},{"location":"tutorials/mesh/03.Altering/#custom-transformations","text":"Besides each of the transformations above, you can define an arbitrary transformation using the Transformation class constructor. For this constructor the elements of the affine transformation matrix are directly provided. Below you can see how the matrix elements map to the constructor parametres. e01 e02 e03 e04 e11 e12 e13 e14 e21 e22 e23 e24 0 0 0 1 var transformation = new Transformation( e01, e02, e03, e04, e11, e12, e13, e14, e21, e22, e23, e24 )","title":"Custom Transformations"},{"location":"tutorials/mesh/03.Altering/#modifier-stacks","text":"Geometry modifiers are non-destructive decorators which can be used to apply arbitrary modifications to geometry. Modifiers can be stacked to apply geometric modifications successively without damaging the original geometry,","title":"Modifier Stacks"},{"location":"tutorials/mesh/03.Altering/#array","text":"The array modifier, Qkmaxware.Geometry.Modifiers.Array , will repeat geometry multiple times moving them by a given amount on each repetition.","title":"Array"},{"location":"tutorials/mesh/03.Altering/#path-deformation","text":"The path deformation modifier, Qkmaxware.Geometry.Modifiers.PathDeform , will deform a geometry such that it follows a path.","title":"Path Deformation"},{"location":"tutorials/mesh/03.Altering/#mirror","text":"The mirror modifier creates a new mesh that is mirrored across the given axis containing both the original triangles as well as the mirrored triangles.","title":"Mirror"},{"location":"tutorials/mesh/03.Altering/#subdivide","text":"The subdivide modifier creates a new mesh in which each triangle has be sub-divided into 4 smaller triangles. This modifier can be used to increase the resolution of a given geometry.","title":"Subdivide"},{"location":"tutorials/mesh/03.Altering/#scale_1","text":"The scale modifier operates identically to the scale transformation. However, by being a modifier it does not allocate any additional mesh data until it is used whereas the transformation immediately creates a new mesh with the modified vertices.","title":"Scale"},{"location":"tutorials/mesh/03.Altering/#translate","text":"the translate modifier operates identically to the offset transformation but as a modifier. This behaves the same as the scale modifier.","title":"Translate"},{"location":"tutorials/mesh/03.Altering/#path-to-mesh","text":"The path to mesh modifier creates a tube shaped mesh by following a path segment. Effectively this allows for one to convert a path object into a 3d mesh which follows the shape of the path.","title":"Path To Mesh"},{"location":"tutorials/mesh/03.Altering/#render-gcode","text":"The render g-code modifier uses tubes to trace the path for a print-head of a 3D printer in order to convert 3D printer flavoured GCode back to a 3d model.","title":"Render GCode"},{"location":"tutorials/mesh/03.Altering/#explode","text":"The explode modifier pushes the original triangles apart as if they were exploded outwards from their original locations.","title":"Explode"},{"location":"tutorials/mesh/03.Altering/#boolean-operations","text":"Boolean operations are a set of operations common in the field of computer aided design. There are several different modifier which are capable of performing boolean operations.","title":"Boolean Operations"},{"location":"tutorials/mesh/03.Altering/#union","text":"the union modifier combines non-overlapping polygons from two geometry into a new geometry. Besides being offered as a modifier, this operation can also be done with the Union method of the ListMesh class, or by using the overloaded + operation.","title":"Union"},{"location":"tutorials/mesh/03.Altering/#difference","text":"the difference modifier is used to cut geometry out of a mesh where it overlaps with another geometry. Besides being offered as a modifier, this operation can also be done using the Difference method of the ListMesh class, or by using the overloaded - operation.","title":"Difference"},{"location":"tutorials/mesh/03.Altering/#intersection","text":"The intersection modifier is used to save only the parts of a geometry where they overlaps with another geometry. Besides being offered as a modifier, this operation can also be done using the Intersection method of the ListMesh class, or by using the overloaded & operation.","title":"Intersection"},{"location":"tutorials/mesh/03.Altering/#raw-triangles","text":"If the above alteration methods do not work for your use case, you can create new geometry by looping over the individual triangles within a mesh and creating new triangles by altering the vertices. IMesh CustomTransformation(IMesh mesh) { List<Triangle> newTriangles = new List<Triangle>(); foreach (var triangle in mesh) { var vertex1 = AlterVertex(triangle.Item1); var vertex2 = AlterVertex(triangle.Item2); var vertex2 = AlterVertex(triangle.Item3); newTriangles.Add(new Triangle(vertex1, vertex2, vertex3)); } return new ListMesh(newTriangles); }","title":"Raw Triangles"},{"location":"tutorials/mesh/04.Exporting/","text":"Exporting 3d Models STL Files Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class. ASCII STL To save an ASCII encoded STL, use the Serialize method of an StlSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new StreamWriter(\"myfile.stl\")) { writer.Write(serializer.Serialize(mesh)); } } } Binary STL To save an binary encoded STL, use the SerializeBinary method of an StlSerializer object to write mesh data to a given BinaryWriter . using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new BinaryWriter(File.Open(\"myfile.stl\", FileMode.Create))) { exporter.SerializeBinary(mesh, writer); } } } Wavefront Obj Files Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class. ASCII Obj To save an ASCII encoded OBJ, use the Serialize method of an ObjSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new ObjSerializer(); using (var writer = new StreamWriter(\"myfile.obj\")) { writer.Write(serializer.Serialize(mesh)); } } } Extensible 3D Graphics X3d Files Extensible 3D Graphics files or X3D files is a royalty free xml based format for representing 3D computer graphics. Given that X3D files are an based on the XML format, there only is an ASCII version available for this format. Saving of X3D files is supported via the Qkmaxware.Geometry.IO.X3dSerializer class. ASCII X3d To save an ASCII encoded X3D, use the Serialize method of an X3dSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new X3dSerializer(); using (var writer = new StreamWriter(\"myfile.x3d\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"Exporting 3d Models"},{"location":"tutorials/mesh/04.Exporting/#exporting-3d-models","text":"","title":"Exporting 3d Models"},{"location":"tutorials/mesh/04.Exporting/#stl-files","text":"Stereolithography CAD files or STL is a 3d file format common in rapid prototyping, 3d printing, and computer aided design. STL files come in in two forms, an ASCII version as well as a Binary version. Loading and saving of STL files for both binary and ASCII version is supported via the Qkmaxware.Geometry.IO.StlSerializer class.","title":"STL Files"},{"location":"tutorials/mesh/04.Exporting/#ascii-stl","text":"To save an ASCII encoded STL, use the Serialize method of an StlSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new StreamWriter(\"myfile.stl\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII STL"},{"location":"tutorials/mesh/04.Exporting/#binary-stl","text":"To save an binary encoded STL, use the SerializeBinary method of an StlSerializer object to write mesh data to a given BinaryWriter . using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new StlSerializer(); using (var writer = new BinaryWriter(File.Open(\"myfile.stl\", FileMode.Create))) { exporter.SerializeBinary(mesh, writer); } } }","title":"Binary STL"},{"location":"tutorials/mesh/04.Exporting/#wavefront-obj-files","text":"Wavefront Obj files are another common file format. Unlike STL and other formats, OBJ files are only available as an ASCII encoded format. Loading and saving of OBJ files is supported via the Qkmaxware.Geometry.IO.ObjSerializer class.","title":"Wavefront Obj Files"},{"location":"tutorials/mesh/04.Exporting/#ascii-obj","text":"To save an ASCII encoded OBJ, use the Serialize method of an ObjSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new ObjSerializer(); using (var writer = new StreamWriter(\"myfile.obj\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII Obj"},{"location":"tutorials/mesh/04.Exporting/#extensible-3d-graphics-x3d-files","text":"Extensible 3D Graphics files or X3D files is a royalty free xml based format for representing 3D computer graphics. Given that X3D files are an based on the XML format, there only is an ASCII version available for this format. Saving of X3D files is supported via the Qkmaxware.Geometry.IO.X3dSerializer class.","title":"Extensible 3D Graphics X3d Files"},{"location":"tutorials/mesh/04.Exporting/#ascii-x3d","text":"To save an ASCII encoded X3D, use the Serialize method of an X3dSerializer object to create an ASCII string representing the geometry that can then be saved to a file. using System.IO; using Qkmaxware.Geometry; using Qkmaxware.Geometry.IO; public class Program { public static void Export(Mesh mesh) { var serializer = new X3dSerializer(); using (var writer = new StreamWriter(\"myfile.x3d\")) { writer.Write(serializer.Serialize(mesh)); } } }","title":"ASCII X3d"},{"location":"tutorials/nurbs/01.CreatingCurves/","text":"Creating Curves NURBS curves are a mathematical model used for representing a curve in three dimensional space that is flexible and precise. NURBS curves are the basis of creating NURBS surfaces and volumes. The NurbsCurve class models the behavior of these curves. Control Points & Knot Vectors You can easily create a new curve using the NurbsCurve constructor. This constructor takes in a list of control points and a parameter that defines how the endpoints behave. The degree of the curve and the knot vector are determined automatically. var curve = new NurbsCurve( new NurbsControlPoint[]{ new NurbsControlPoint(new Vec3(-4, -4, 0), 1), new NurbsControlPoint(new Vec3(-2, 4, 0), 1), new NurbsControlPoint(new Vec3(2, -4, 0), 1), new NurbsControlPoint(new Vec3(4, 4, 0), 1) }, NurbsPinning.PinBoth ); For more precise control over the curve's behaviour, there is a second constructor in which the degree and knot vector are explicitly provided. var w = Math.Sqrt(2) / 2; var controls = new NurbsControlPoint[]{ new NurbsControlPoint(center + new Vec3(1, 0, 0), 1), new NurbsControlPoint(center + new Vec3(1, 1, 0), w), new NurbsControlPoint(center + new Vec3(0, 1, 0), 1), new NurbsControlPoint(center + new Vec3(-1, 1, 0), w), new NurbsControlPoint(center + new Vec3(-1, 0, 0), 1), new NurbsControlPoint(center + new Vec3(-1, -1, 0), w), new NurbsControlPoint(center + new Vec3(0, -1, 0), 1), new NurbsControlPoint(center + new Vec3(1, -1, 0), w), new NurbsControlPoint(center + new Vec3(1, 0, 0), 1), }; var knots = new double[]{ 0, 0, 0, Math.PI / 2, Math.PI / 2, Math.PI, Math.PI, 3 * Math.PI / 2, 3 * Math.PI / 2, 2 * Math.PI, 2 * Math.PI, 2 * Math.PI }; return new NurbsCurve(2, controls, knots); Evaluating Points With a NURBS curve created you can evaluate points on that curve using an interpolation parameter. To support this, the NurbsCurve class provided an indexor property which can be used. Provide a value between 0 and 1 as a parameter and the three dimension vector representing that point on the curve will be returned. NurbsCurve curve = ...; var midpoint = curve[0.5];","title":"Creating Curves"},{"location":"tutorials/nurbs/01.CreatingCurves/#creating-curves","text":"NURBS curves are a mathematical model used for representing a curve in three dimensional space that is flexible and precise. NURBS curves are the basis of creating NURBS surfaces and volumes. The NurbsCurve class models the behavior of these curves.","title":"Creating Curves"},{"location":"tutorials/nurbs/01.CreatingCurves/#control-points-knot-vectors","text":"You can easily create a new curve using the NurbsCurve constructor. This constructor takes in a list of control points and a parameter that defines how the endpoints behave. The degree of the curve and the knot vector are determined automatically. var curve = new NurbsCurve( new NurbsControlPoint[]{ new NurbsControlPoint(new Vec3(-4, -4, 0), 1), new NurbsControlPoint(new Vec3(-2, 4, 0), 1), new NurbsControlPoint(new Vec3(2, -4, 0), 1), new NurbsControlPoint(new Vec3(4, 4, 0), 1) }, NurbsPinning.PinBoth ); For more precise control over the curve's behaviour, there is a second constructor in which the degree and knot vector are explicitly provided. var w = Math.Sqrt(2) / 2; var controls = new NurbsControlPoint[]{ new NurbsControlPoint(center + new Vec3(1, 0, 0), 1), new NurbsControlPoint(center + new Vec3(1, 1, 0), w), new NurbsControlPoint(center + new Vec3(0, 1, 0), 1), new NurbsControlPoint(center + new Vec3(-1, 1, 0), w), new NurbsControlPoint(center + new Vec3(-1, 0, 0), 1), new NurbsControlPoint(center + new Vec3(-1, -1, 0), w), new NurbsControlPoint(center + new Vec3(0, -1, 0), 1), new NurbsControlPoint(center + new Vec3(1, -1, 0), w), new NurbsControlPoint(center + new Vec3(1, 0, 0), 1), }; var knots = new double[]{ 0, 0, 0, Math.PI / 2, Math.PI / 2, Math.PI, Math.PI, 3 * Math.PI / 2, 3 * Math.PI / 2, 2 * Math.PI, 2 * Math.PI, 2 * Math.PI }; return new NurbsCurve(2, controls, knots);","title":"Control Points &amp; Knot Vectors"},{"location":"tutorials/nurbs/01.CreatingCurves/#evaluating-points","text":"With a NURBS curve created you can evaluate points on that curve using an interpolation parameter. To support this, the NurbsCurve class provided an indexor property which can be used. Provide a value between 0 and 1 as a parameter and the three dimension vector representing that point on the curve will be returned. NurbsCurve curve = ...; var midpoint = curve[0.5];","title":"Evaluating Points"}]}